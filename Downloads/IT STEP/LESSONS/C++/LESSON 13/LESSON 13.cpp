#include <iostream>
using namespace std;

//int main() {
//	int x = 10;
//	cout << &x << "\n"; // операція взяття адреси &
//	int* px = &x;
//	cout << px << "\n";
//
//	cout << *px << "\n"; // операція взяття вмісту
//	*px = 20;
//	cout << x << "\n"; // 20
//	// *px == x
//	// px = &x
//}


//void increment(int x) {
//
//	x++;
//
//} // зміни були застосовані до КОПІІ значення х, а не до самого х
//
//int main() {
//
//	int x = 10;
//
//	increment(x); // передача аргумента х ПО ЗНАЧЕННЮ (створюється копія)
//
//	cout << x << "\n"; // 11
//
//}


//void increment(int* px) {
//	(*px)++; // x++
//} // *px - опосередкований доступ до оригінала змінної х з мейну
//
//int main() {
//	int x = 10;
//	increment(&x); // передача аргумента х ЗА АДРЕСОЮ (НЕ створюється копія)
//	cout << x << "\n"; // 11
//}


//void perestanovka(int* a, int* b) {
//    int temp = *a;
//    *a = *b;
//    *b = temp;
//}
//
//int main() {
//    int x = 15;
//    int y = 30;
//
//    perestanovka(&x, &y);
//    cout << x << " " << y << "\n";
//}


//int main() {
//	int* px = nullptr;
//	// нульовий покажчик - програміст знає, що покажчик буде потрібен, але яку адресу в нього записати - поки невідомо
//	// робити операцію взяття вмісту не можна (буде ПЕВ, помилка на етапі виконання), але можна роздрукувати такий покажчик без наслідків (навідміну від взагалі не проініціалізованого покажчика, там буде ПЕК, помилка на етапі компіляції)
//	cout << px << "\n"; // 0000000000000000
//	cout << "OK\n";
//}


//int main() {
//	int x = 10; // звичайна змінна
//	int* px = &x; // покажчик на змінну
//	int** ppx = &px; // покажчик на покажчик на змінну
//	// навіщо це на практиці? **
//	// 1) робота з ДВОвимірними ДИНАМІЧНИМИ масивами (*** - трьовимірний масив, **** - чотиривимірний масив)
//	// 2) іноді самі покажчики створюються в одній функції, а мають бути змінені - в іншій функції
//}

//int main() {
//	int x = 10; // звичайна змінна
//	int* px = &x; // покажчик на змінну
//	int** ppx = &px; // покажчик на покажчик на змінну
//	int*** pppx = &ppx; // ПнаПнаП
//	int**** ppppx = &pppx;
//	int***** pppppx = &ppppx;
//	cout << x << "\n"; // 10
//	cout << *px << "\n"; // 10
//	cout << **ppx << "\n"; // 10
//	cout << ***pppx << "\n"; // 10
//	cout << ****ppppx << "\n"; // 10
//	cout << *****pppppx << "\n";
//
//    cout << (x **px && **ppx && ***pppx && ****ppppx && *****pppppx) << "\n";
//}


//int main() {
//	int x = 10; // 4Б
//	double d = 20; // 8Б
//	int* px = &d; // покажчику мало знати адресу, він ще має розуміти яку кількість байтів підряд треба зчитати по цій адресі!
//	// помилка, тому що покажчик перейде по адресі, але прочитає лише 4 байти з 8
//	cout << *px << "\n"; // 20
//	// можна спробувати "заспокоїти" компілятор і виконати перетворення типів, але для покажчиків такую операцію робити небажано
//	int* px = (int*)&d;
//	cout << *px << "\n"; // очікувалось 20, але зчитано було значення 0, тому що покажчик "побачив" лише 4 байти з 8
//}


//int main() {
//	int x = 10;
//	double d = 20;
//	short s = 30;
//
//	// універсальний покажчик (цар покажчиків, покажчик на невизначений тип)
	//void* ptr = &x;
	//// такий покажчик може в собі зберігати БУДЬ ЯКУ АДРЕСУ будь якого об'єекта будь якого типу
//	ptr = &s;
//	ptr = &ptr;
//	ptr = &main;
//	ptr = &d;
//	// перед операцією взяття вмісту ТРЕЬА пояснити, яку кількість байтів треба зчитати
//	cout << *(double*)ptr << "\n";
//
//}


// алгоритм додавання, кількіс елементу в кінець масиву
// 1) створити ЩЕ ОДИН масивть елементів якого на 1 більше ніж в оригінального (старого) масиву
// 2) зберегти базову адресу нового масиву в окремий тимчасовий покажчик
// 3) запустити цикл, який перенесе всі елементи зі старого масиву в новий (скопіює значення по індексах 0-0 1-1 2-2 3-3 4-4
// 4) в кінець нового масиву треба додати потрібне значення
// 5) почистити пам'ять від старого масиву (делітом)
// 6) переставити покажчик на новий масив
// 7) збільшити кількість елементів на 1 у змінній сайз